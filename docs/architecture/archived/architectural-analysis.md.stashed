# Architectural Analysis & Refactoring Recommendations

> **Note:** This document focuses on **code quality and refactoring**, separate from the API calling strategy.
> **For API architecture:** See `MASTER-ARCHITECTURE.md` for the canonical API calling strategy.

**Date:** Generated by Senior Software Architect Review
**Scope:** Full codebase architecture review focusing on code quality, DRY principles, design patterns, and potential issues

---

## Executive Summary

This document identifies critical architectural issues, code smells, design problems, and opportunities for significant code deduplication across the Tickered codebase. The primary concerns center around:

1. **Massive Code Duplication** (~800+ lines of duplicated logic)
2. **Inconsistent Type Patterns** between database and card representations
3. **Missing Abstractions** for common initialization patterns
4. **Type Safety Issues** with profile data extraction
5. **Repeated Error Handling Patterns**

---

## Critical Issues

### 1. MASSIVE CODE DUPLICATION: Profile Info Extraction

**Severity:** üî¥ CRITICAL
**Impact:** ~500+ lines of duplicated code across 8+ card types
**Location:** All card initializer files

#### Problem

Every card initializer duplicates the same pattern for extracting profile information:

```typescript
// This pattern is repeated in:
// - priceCardUtils.ts
// - revenueCardUtils.ts
// - revenueBreakdownCardUtils.ts
// - solvencyCardUtils.ts
// - cashUseCardUtils.ts
// - keyRatiosCardUtils.ts
// - dividendsHistoryCardUtils.ts
// - analystGradesCardUtils.ts

const profileCardForSymbol = activeCards?.find(
  (c) => c.symbol === symbol && c.type === "profile"
) as ProfileDBRowFromSupabase | undefined;

let fetchedProfileInfo = {
  companyName: profileCardForSymbol?.company_name ?? symbol,
  displayCompanyName:
    profileCardForSymbol?.display_company_name ??
    profileCardForSymbol?.company_name ??
    symbol,
  logoUrl: profileCardForSymbol?.image ?? null,
  websiteUrl: profileCardForSymbol?.website ?? null,
};

if (!profileCardForSymbol) {
  const profileResult = await fromPromise(
    supabase
      .from("profiles")
      .select("company_name, display_company_name, image, website")
      .eq("symbol", symbol)
      .maybeSingle(),
    (e) => new [CardName]CardError(`Failed to fetch profile: ${(e as Error).message}`)
  );

  if (profileResult.isOk() && profileResult.value.data) {
    const profileData = profileResult.value.data as ProfileDBRowFromSupabase;
    fetchedProfileInfo = {
      companyName: profileData.company_name ?? symbol,
      displayCompanyName:
        profileData.display_company_name ??
        profileData.company_name ??
        symbol,
      logoUrl: profileData.image ?? null,
      websiteUrl: profileData.website ?? null,
    };
  } else if (profileResult.isErr()) {
    console.warn(profileResult.error.message);
  }
}
```

#### Issues

1. **Type Inconsistency**: Mixing `ProfileDBRowFromSupabase` (DB type) with `ProfileCardData` (card type)
2. **Different Property Access**: Some use `company_name` (DB), some use `companyName` (Card)
3. **Inconsistent Fallbacks**: Different default value strategies
4. **Repeated Supabase Queries**: Same query logic duplicated
5. **No Error Aggregation**: Each initializer handles errors differently

#### Solution

Create a centralized profile extraction service:

```typescript
// src/components/game/cards/services/profileExtractionService.ts

export interface ProfileInfo {
  companyName: string | null;
  displayCompanyName: string | null;
  logoUrl: string | null;
  websiteUrl: string | null;
  currency?: string | null;
  exchange?: string | null;
}

export async function extractProfileInfo(
  symbol: string,
  activeCards: DisplayableCard[] | undefined,
  supabase: SupabaseClient<Database>,
  errorClass: typeof Error
): Promise<Result<ProfileInfo, Error>> {
  // 1. Try to extract from existing profile card
  const profileCard = activeCards?.find(
    (c) => c.symbol === symbol && c.type === "profile"
  ) as ProfileCardData | undefined;

  if (profileCard) {
    return ok({
      companyName: profileCard.companyName ?? null,
      displayCompanyName: profileCard.displayCompanyName ?? null,
      logoUrl: profileCard.logoUrl ?? null,
      websiteUrl: profileCard.websiteUrl ?? null,
      currency: profileCard.staticData.currency ?? null,
      exchange: profileCard.staticData.exchange ?? null,
    });
  }

  // 2. Fallback to database fetch
  const profileResult = await fromPromise(
    supabase
      .from("profiles")
      .select("company_name, display_company_name, image, website, currency, exchange")
      .eq("symbol", symbol)
      .maybeSingle(),
    (e) => new errorClass(`Failed to fetch profile: ${(e as Error).message}`)
  );

  if (profileResult.isErr()) {
    // Log warning but return defaults
    console.warn(`[ProfileExtraction] ${profileResult.error.message}`);
    return ok({
      companyName: symbol,
      displayCompanyName: symbol,
      logoUrl: null,
      websiteUrl: null,
      currency: null,
      exchange: null,
    });
  }

  const profileData = profileResult.value.data;
  if (!profileData) {
    return ok({
      companyName: symbol,
      displayCompanyName: symbol,
      logoUrl: null,
      websiteUrl: null,
      currency: null,
      exchange: null,
    });
  }

  return ok({
    companyName: profileData.company_name ?? symbol,
    displayCompanyName:
      profileData.display_company_name ??
      profileData.company_name ??
      symbol,
    logoUrl: profileData.image ?? null,
    websiteUrl: profileData.website ?? null,
    currency: profileData.currency ?? null,
    exchange: profileData.exchange ?? null,
  });
}
```

**Estimated Code Reduction:** ~400 lines

---

### 2. INCONSISTENT TYPE SYSTEM: Profile Data Representation

**Severity:** üü° HIGH
**Impact:** Type safety issues, runtime errors potential
**Location:** Throughout card utilities

#### Problem

The codebase mixes two different representations of profile data:

1. **Database Type** (`ProfileDBRowFromSupabase`): Uses snake_case (`company_name`)
2. **Card Type** (`ProfileCardData`): Uses camelCase (`companyName`)

This causes:
- Type assertions that bypass type safety (`as ProfileDBRowFromSupabase`)
- Incorrect property access (trying to access `company_name` on card data)
- Confusion about which type is being used where

#### Example from priceCardUtils.ts:

```typescript
// ‚ùå BAD: Type assertion bypasses type safety
const profileCard = activeCards?.find(
  (c) => c.symbol === symbol && c.type === "profile"
) as ProfileCardDataType | undefined;

// ‚ùå BAD: Accessing wrong properties (card has companyName, not company_name)
if (profileCard) {
  profileContext = {
    company_name: profileCard.companyName ?? null,  // Mixed naming
    display_company_name: profileCard.displayCompanyName ?? null,
    // ...
  };
}
```

#### Solution

1. Create a unified type adapter/transformer
2. Always extract profile info through the centralized service
3. Use discriminated unions for type safety

```typescript
// Unified profile extraction with proper types
export function getProfileInfo(
  card: ProfileCardData | undefined,
  fallbackSymbol: string
): ProfileInfo {
  if (!card) {
    return createDefaultProfileInfo(fallbackSymbol);
  }

  return {
    companyName: card.companyName,
    displayCompanyName: card.displayCompanyName,
    logoUrl: card.logoUrl,
    websiteUrl: card.websiteUrl,
    currency: card.staticData.currency,
    exchange: card.staticData.exchange,
  };
}
```

---

### 3. DUPLICATED CARD CONSTRUCTION PATTERNS

**Severity:** üü° HIGH
**Impact:** ~200+ lines of similar construction logic
**Location:** Multiple card utils files

#### Problem

Multiple cards have similar construction patterns:

```typescript
// Pattern repeated in:
// - constructRevenueCardData()
// - constructSolvencyCardData()
// - constructKeyRatiosCardData()
// - constructDividendsHistoryCardData()
// - constructCashUseCardData()
// - constructAnalystGradesCardData()

function construct[CardName]CardData(
  dbRow: DatabaseRow,
  profileInfo: {
    companyName?: string | null;
    displayCompanyName?: string | null;
    logoUrl?: string | null;
    websiteUrl?: string | null;
  },
  idOverride?: string | null,
  existingCreatedAt?: number | null
): [CardName]CardData {
  const staticData: [CardName]CardStaticData = {
    // Card-specific static data
  };

  const liveData: [CardName]CardLiveData = {
    // Card-specific live data
  };

  const cardBackData: BaseCardBackData = {
    description: `Description for ${profileInfo.companyName || symbol}`,
  };

  return {
    id: idOverride || `[cardname]-${symbol}-${Date.now()}`,
    type: "[cardname]",
    symbol: symbol,
    companyName: profileInfo.companyName ?? symbol,
    displayCompanyName: profileInfo.displayCompanyName ?? profileInfo.companyName ?? symbol,
    logoUrl: profileInfo.logoUrl ?? null,
    websiteUrl: profileInfo.websiteUrl ?? null,
    createdAt: existingCreatedAt ?? Date.now(),
    staticData,
    liveData,
    backData: cardBackData,
  };
}
```

#### Solution

Create a base card construction utility:

```typescript
// src/components/game/cards/services/cardConstructionService.ts

export interface BaseCardConstructionParams {
  symbol: string;
  cardType: CardType;
  profileInfo: ProfileInfo;
  staticData: unknown; // Card-specific
  liveData: unknown; // Card-specific
  backDescription: string;
  idOverride?: string | null;
  existingCreatedAt?: number | null;
}

export function constructBaseCard<T extends ConcreteCardData>(
  params: BaseCardConstructionParams & {
    staticData: T["staticData"];
    liveData: T["liveData"];
  }
): Omit<T, "id" | "createdAt"> & { id: string; createdAt: number } {
  const { symbol, cardType, profileInfo, staticData, liveData, backDescription, idOverride, existingCreatedAt } = params;

  return {
    id: idOverride || `${cardType}-${symbol}-${Date.now()}`,
    type: cardType,
    symbol,
    companyName: profileInfo.companyName ?? symbol,
    displayCompanyName: profileInfo.displayCompanyName ?? profileInfo.companyName ?? symbol,
    logoUrl: profileInfo.logoUrl ?? null,
    websiteUrl: profileInfo.websiteUrl ?? null,
    createdAt: existingCreatedAt ?? Date.now(),
    staticData,
    liveData,
    backData: { description: backDescription },
  } as Omit<T, "id" | "createdAt"> & { id: string; createdAt: number };
}
```

**Estimated Code Reduction:** ~150 lines

---

### 4. REPEATED SHELL CARD CREATION

**Severity:** üü¢ MEDIUM
**Impact:** ~100 lines, specific to price card
**Location:** priceCardUtils.ts

#### Problem

Price card has special shell card creation logic that could be abstracted:

```typescript
// In priceCardUtils.ts - lines 206-243
const shellLeanQuote: LiveQuoteIndicatorDBRow = {
  id: `shell-indicator-${now}`,
  symbol: symbol,
  current_price: 0,
  // ... many null properties
};
```

This pattern could be reused by other cards that need shell states.

#### Solution

Create a shell card factory:

```typescript
// src/components/game/cards/services/shellCardFactory.ts

export function createShellQuoteIndicator(
  symbol: string,
  exchange?: string | null
): LiveQuoteIndicatorDBRow {
  const now = Date.now();
  return {
    id: `shell-indicator-${now}`,
    symbol,
    exchange: exchange ?? null,
    current_price: 0,
    api_timestamp: Math.floor(now / 1000),
    fetched_at: new Date(now).toISOString(),
    // All other fields null
    change_percentage: null,
    day_change: null,
    volume: null,
    // ... rest of null fields
  };
}
```

---

### 5. INCONSISTENT ERROR HANDLING

**Severity:** üü° HIGH
**Impact:** Maintenance burden, inconsistent user experience
**Location:** All card initializers

#### Problem

Error handling patterns vary across cards:

1. Some cards create custom error classes ‚úÖ
2. Some cards return generic Error ‚ùå
3. Some cards log warnings, some don't ‚ùå
4. Some cards show toasts, some don't ‚ùå
5. Error messages are inconsistent ‚ùå

#### Solution

Standardize error handling:

```typescript
// src/components/game/cards/services/cardInitializationError.ts

export class CardInitializationError extends Error {
  constructor(
    public readonly cardType: CardType,
    public readonly symbol: string,
    message: string,
    public readonly cause?: Error
  ) {
    super(message);
    this.name = "CardInitializationError";
  }

  static fromError(
    cardType: CardType,
    symbol: string,
    error: Error
  ): CardInitializationError {
    return new CardInitializationError(
      cardType,
      symbol,
      `Failed to initialize ${cardType} card for ${symbol}: ${error.message}`,
      error
    );
  }
}

// Standardized error handling wrapper
export async function handleCardInitialization<T>(
  cardType: CardType,
  symbol: string,
  operation: () => Promise<Result<T, Error>>,
  toast?: ToastFunctionType
): Promise<Result<T, CardInitializationError>> {
  const result = await operation();

  return result.mapErr((error) => {
    const cardError = CardInitializationError.fromError(cardType, symbol, error);

    // Log consistently
    console.warn(`[${cardType}Card] ${cardError.message}`, cardError.cause);

    // Show toast consistently
    if (toast) {
      toast({
        title: "Card Initialization Failed",
        description: cardError.message,
        variant: "destructive",
      });
    }

    return cardError;
  });
}
```

---

### 6. DUPLICATED BACK DATA DESCRIPTION PATTERNS

**Severity:** üü¢ MEDIUM
**Impact:** ~100 lines, inconsistent descriptions
**Location:** All card construction functions

#### Problem

Back card descriptions follow similar patterns but are constructed inconsistently:

```typescript
// Different patterns across cards:
const backDataDescription: BaseCardBackData = {
  description: `Market price information for ${companyNameForDesc}. Includes daily and historical price points, volume, and key moving averages.`,
};

const cardBackData: BaseCardBackData = {
  description: `Key financial metrics for ${profileInfo.companyName || dbRow.symbol} (${staticData.periodLabel}, ending ${staticData.statementDate || "N/A"}). Includes revenue, profits, and free cash flow.`,
};

const cardTypeDescription = `Provides an overview of ${dbData.company_name || dbData.symbol}'s company profile, including sector, industry, and key operational highlights.`;
```

#### Solution

Create description generators:

```typescript
// src/components/game/cards/services/cardDescriptionService.ts

export interface CardDescriptionContext {
  companyName: string;
  symbol: string;
  cardType: CardType;
  additionalContext?: Record<string, string>;
}

export function generateCardDescription(
  context: CardDescriptionContext
): string {
  const { companyName, symbol, cardType, additionalContext } = context;
  const displayName = companyName || symbol;

  const descriptions: Record<CardType, (ctx: CardDescriptionContext) => string> = {
    price: () => `Market price information for ${displayName}. Includes daily and historical price points, volume, and key moving averages.`,
    profile: () => `Provides an overview of ${displayName}'s company profile, including sector, industry, and key operational highlights.`,
    revenue: () => {
      const period = additionalContext?.periodLabel || "N/A";
      const date = additionalContext?.statementDate || "N/A";
      return `Key financial metrics for ${displayName} (${period}, ending ${date}). Includes revenue, profits, and free cash flow.`;
    },
    // ... other card types
  };

  const generator = descriptions[cardType];
  return generator ? generator(context) : `Information about ${displayName}`;
}
```

---

### 7. TYPE SYSTEM ISSUES: Update Handler Registry

**Severity:** üü° HIGH
**Impact:** Type safety bypassed with `as unknown as`
**Location:** cardUpdateHandler.types.ts

#### Problem

The update handler registry uses unsafe type casts:

```typescript
// From cardUpdateHandler.types.ts - lines 67-74
// The 'as unknown as StoredCardUpdateHandler' cast bypasses this check.
// We assert this is safe because getCardUpdateHandler is expected to be used
// in a context where the specific TCardData is known (e.g., via cardType).
eventMap?.set(eventType, handler as unknown as StoredCardUpdateHandler);
```

This is a code smell indicating the type system isn't properly modeling the relationship.

#### Solution

Improve type safety with proper generic constraints:

```typescript
// Better type-safe registry
type TypedCardUpdateHandler<
  TCardData extends ConcreteCardData,
  TPayload
> = (
  currentCardData: TCardData,
  payload: TPayload,
  context: CardUpdateContext
) => TCardData;

interface HandlerRegistry {
  register<TCardData extends ConcreteCardData, TPayload>(
    cardType: CardType,
    eventType: CardUpdateEventType,
    handler: TypedCardUpdateHandler<TCardData, TPayload>
  ): void;

  get(
    cardType: CardType,
    eventType: CardUpdateEventType
  ): TypedCardUpdateHandler<ConcreteCardData, unknown> | undefined;
}
```

Or use a more sophisticated type-safe registry pattern.

---

### 8. MISSING ABSTRACTION: Card Initialization Flow

**Severity:** üü° HIGH
**Impact:** Repeated initialization patterns
**Location:** All card initializers

#### Problem

All card initializers follow a similar pattern:

1. Extract profile info (duplicated)
2. Fetch card-specific data from Supabase
3. Transform data to card format
4. Construct card object
5. Handle errors

But there's no base class or template for this flow.

#### Solution

Create a base initialization template:

```typescript
// src/components/game/cards/services/baseCardInitializer.ts

export abstract class BaseCardInitializer<TCardData extends ConcreteCardData> {
  abstract readonly cardType: CardType;
  abstract readonly errorClass: typeof Error;

  async initialize(
    context: CardInitializationContext
  ): Promise<Result<DisplayableCard, Error>> {
    // 1. Extract profile info (centralized)
    const profileInfoResult = await extractProfileInfo(
      context.symbol,
      context.activeCards,
      context.supabase,
      this.errorClass
    );

    if (profileInfoResult.isErr()) {
      return err(new this.errorClass(profileInfoResult.error.message));
    }

    const profileInfo = profileInfoResult.value;

    // 2. Fetch card-specific data (implemented by subclass)
    const dataResult = await this.fetchCardData(context);

    if (dataResult.isErr()) {
      return err(dataResult.error);
    }

    // 3. Transform to card format (implemented by subclass)
    const cardData = this.transformToCard(
      dataResult.value,
      profileInfo,
      context
    );

    // 4. Construct and return
    return ok({
      ...cardData,
      isFlipped: false,
    });
  }

  protected abstract fetchCardData(
    context: CardInitializationContext
  ): Promise<Result<unknown, Error>>;

  protected abstract transformToCard(
    data: unknown,
    profileInfo: ProfileInfo,
    context: CardInitializationContext
  ): TCardData;
}
```

Then card initializers become:

```typescript
class PriceCardInitializer extends BaseCardInitializer<PriceCardData> {
  readonly cardType = "price" as const;
  readonly errorClass = PriceCardError;

  protected async fetchCardData(context: CardInitializationContext) {
    return await fetchQuoteData(context.supabase, context.symbol);
  }

  protected transformToCard(
    quote: LiveQuoteIndicatorDBRow,
    profileInfo: ProfileInfo,
    context: CardInitializationContext
  ): PriceCardData {
    return createPriceCardData(quote, profileInfo);
  }
}
```

**Estimated Code Reduction:** ~300 lines

---

## Design Smells & Code Quality Issues

### 9. Inconsistent Naming Conventions

- Some use `profileCardForSymbol`, some use `profileCard`
- Some use `fetchedProfileInfo`, some use `profileInfo`
- Mix of camelCase and snake_case in same contexts

**Fix:** Standardize on `profileInfo` and use consistent naming throughout.

### 10. Magic Strings and Hard-coded Values

- Card type strings repeated: `"profile"`, `"price"`, etc.
- Error message strings duplicated
- Hard-coded default values (`"USD"`, `"$"`, etc.)

**Fix:** Use constants and enums:

```typescript
export const DEFAULT_CURRENCY = "USD";
export const DEFAULT_CURRENCY_SYMBOL = "$";
export const CARD_TYPES = {
  PROFILE: "profile",
  PRICE: "price",
  // ...
} as const;
```

### 11. Large Function Bodies

Some initializer functions are 100+ lines. Break down into smaller, testable functions.

### 12. Missing Unit Tests

Critical utility functions lack unit tests. The `applyProfileCoreUpdates` function in `cardUtils.ts` is good but needs tests.

---

## Recommended Refactoring Priority

### Phase 1: Critical Duplication (Highest Impact)
1. ‚úÖ Create `profileExtractionService.ts` - **~400 lines saved**
2. ‚úÖ Refactor all card initializers to use centralized profile extraction
3. ‚úÖ Fix type inconsistencies

### Phase 2: Construction Patterns
4. ‚úÖ Create `cardConstructionService.ts` - **~150 lines saved**
5. ‚úÖ Create `cardDescriptionService.ts` - **~100 lines saved**
6. ‚úÖ Standardize card construction across all cards

### Phase 3: Error Handling
7. ‚úÖ Create `CardInitializationError` class
8. ‚úÖ Standardize error handling wrapper
9. ‚úÖ Update all initializers to use standardized errors

### Phase 4: Architecture Improvements
10. ‚úÖ Create `BaseCardInitializer` abstract class
11. ‚úÖ Refactor cards to extend base class
12. ‚úÖ Improve update handler type safety

### Phase 5: Polish & Optimization
13. ‚úÖ Extract constants and enums
14. ‚úÖ Add comprehensive unit tests
15. ‚úÖ Refactor large functions into smaller units

---

## Estimated Impact

- **Code Reduction:** ~1,000+ lines eliminated
- **Maintainability:** Significant improvement (single source of truth)
- **Type Safety:** Improved (eliminate unsafe casts)
- **Testability:** Improved (isolated, testable functions)
- **Consistency:** Improved (standardized patterns)

---

## Additional Recommendations

### 1. Create Shared Types Module

```typescript
// src/components/game/cards/types/shared.ts
export interface BaseCardMetadata {
  id: string;
  type: CardType;
  symbol: string;
  createdAt: number;
  companyName: string | null;
  displayCompanyName: string | null;
  logoUrl: string | null;
  websiteUrl: string | null;
}

export interface ProfileInfo {
  companyName: string | null;
  displayCompanyName: string | null;
  logoUrl: string | null;
  websiteUrl: string | null;
  currency: string | null;
  exchange: string | null;
}
```

### 2. Create Card Factory Pattern

For cards that need complex initialization, use a factory pattern.

### 3. Add Integration Tests

Test the full initialization flow with mocked Supabase responses.

### 4. Document Card Lifecycle

Create clear documentation for:
- Card initialization
- Card updates
- Card rehydration
- Card deletion

---

## Conclusion

The codebase has significant opportunities for improvement through:

1. **Deduplication** (~1,000 lines)
2. **Type Safety** (eliminate unsafe casts)
3. **Consistency** (standardize patterns)
4. **Maintainability** (single source of truth)
5. **Testability** (isolated functions)

Priority should be given to Phase 1 (profile extraction) as it has the highest impact and affects the most code.

