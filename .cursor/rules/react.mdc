---
description: React best practices and patterns for modern web applications
globs: **/*.tsx, **/*.jsx, components/**/*
---

# React Best Practices

**Version:** React 19 RC (react: ^19.0.0-rc.1)

## React 19 Features

### Server Actions
Use async Server Actions for form submissions and mutations. **Note:** Server Actions can use direct Supabase queries for simplicity, but consider using Result types for consistency:

```typescript
// app/actions/submit-form.ts
"use server";

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { fromPromise } from "neverthrow";

export async function submitForm(formData: FormData) {
  const supabase = await createSupabaseServerClient();
  const symbol = formData.get("symbol") as string;

  // âœ… GOOD: Using fromPromise for consistency
  const result = await fromPromise(
    supabase.from("table").insert({ symbol }),
    (e) => e as Error
  );

  return result.match(
    (response) => {
      const { data, error } = response;
      if (error) {
        return { success: false, error: error.message };
      }
      return { success: true, data };
    },
    (error) => ({
      success: false,
      error: error.message,
    })
  );
}
```

### useFormStatus
Access form submission state in form components:
```typescript
"use client";

import { useFormStatus } from "react-dom";
import { Button } from "@/components/ui/button";

function SubmitButton() {
  const { pending } = useFormStatus();

  return (
    <Button type="submit" disabled={pending}>
      {pending ? "Submitting..." : "Submit"}
    </Button>
  );
}
```

### useOptimistic
Optimistically update UI before server confirmation:
```typescript
"use client";

import { useOptimistic } from "react";

function CardList({ cards }: { cards: Card[] }) {
  const [optimisticCards, addOptimisticCard] = useOptimistic(
    cards,
    (state, newCard: Card) => [...state, newCard]
  );

  async function handleAddCard(card: Card) {
    addOptimisticCard(card); // Immediately update UI
    await submitCard(card); // Then sync with server
  }

  return (
    <div>
      {optimisticCards.map(card => <Card key={card.id} data={card} />)}
    </div>
  );
}
```

### Improved Suspense
Better integration with Server Components and data fetching:
```typescript
// app/workspace/page.tsx
import { Suspense } from "react";
import { WorkspaceContent } from "./workspace-content";

export default function WorkspacePage() {
  return (
    <Suspense fallback={<WorkspaceSkeleton />}>
      <WorkspaceContent />
    </Suspense>
  );
}

// workspace-content.tsx (Server Component)
async function WorkspaceContent() {
  const supabase = await createSupabaseServerClient();
  const { data } = await supabase.from("cards").select("*");

  return <Workspace cards={data} />;
}
```

## Component Structure
- Use functional components over class components
- Keep components small and focused
- Extract reusable logic into custom hooks
- Use composition over inheritance
- Implement proper prop types with TypeScript
- Split large components into smaller, focused ones

## Hooks
- Follow the Rules of Hooks
- Use custom hooks for reusable logic
- Keep hooks focused and simple
- Use appropriate dependency arrays in useEffect
- Implement cleanup in useEffect when needed
- Avoid nested hooks

## State Management
- Use useState for local component state
- Implement useReducer for complex state logic
- Use Context API for shared state
- Keep state as close to where it's used as possible
- Avoid prop drilling through proper state management
- Use state management libraries only when necessary

## Performance
- Implement proper memoization (useMemo, useCallback)
- Use React.memo for expensive components
- Avoid unnecessary re-renders
- Implement proper lazy loading
- Use proper key props in lists
- Profile and optimize render performance

## Forms
- Use controlled components for form inputs
- Implement proper form validation
- Handle form submission states properly
- Show appropriate loading and error states
- Use form libraries for complex forms
- Implement proper accessibility for forms

## Error Handling
- Implement Error Boundaries
- Handle async errors properly
- Show user-friendly error messages
- Implement proper fallback UI
- Log errors appropriately
- Handle edge cases gracefully

## Testing
- Write unit tests for components
- Implement integration tests for complex flows
- Use React Testing Library
- Test user interactions
- Test error scenarios
- Implement proper mock data

## Accessibility
- Use semantic HTML elements
- Implement proper ARIA attributes
- Ensure keyboard navigation
- Test with screen readers
- Handle focus management
- Provide proper alt text for images

## Code Organization
- Group related components together
- Use proper file naming conventions
- Implement proper directory structure
- Keep styles close to components
- Use proper imports/exports
- Document complex component logic